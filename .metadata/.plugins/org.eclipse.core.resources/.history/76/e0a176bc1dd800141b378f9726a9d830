/**************************************************************************************************
  Filename:       peripheral.c
  Revised:        $Date: 2013-09-23 08:15:44 -0700 (Mon, 23 Sep 2013) $
  Revision:       $Revision: 35416 $

  Description:    GAP Peripheral Role

**************************************************************************************************/

/*********************************************************************
 * INCLUDES
 */
#include "BLE_HCI.h"


/*********************************************************************
 * MACROS
 */

/*********************************************************************
 * CONSTANTS
 */


/*********************************************************************
 * TYPEDEFS
 */


/*********************************************************************
 * GLOBAL VARIABLES
 */

static MBLEDevice_s bleMaster;
static PBLEDevice_s *bleDeviceDB[NUMOFDEVICES];

static uint8 numOfDevices_InRange = 0;
/*********************************************************************
 * EXTERNAL VARIABLES
 */

/*********************************************************************
 * EXTERNAL FUNCTIONS EXT
 */

/*********************************************************************
 * LOCAL VARIABLES Static
 */

/*********************************************************************
 * @fn          errorStatusHdr
 *
 * @brief
 * 		 This is the error Code Handler to recover from a bad packet
 * 		 when the BLE Device(CC2540) sends and HCI error code.
 *
 * @params 	uint8 errorCode
 * @return void
 *
 *  */
void errorStatusHdr(uint8 errorCode)
{
	switch(errorCode)
	{

	case bleNotReady:break;

	case bleNotConnected:break;

	case bleTimeout :break;

	case bleGAPUserCanceled:break;
	}

}
/*********************************************************************
 * @fn          BLE_ProcessEvent
 *
 * @brief
 * 		 This is the event handler function for all BLE processes for GAP and
 *  	 GATT commands and events. It calls message processing functions to
 *  	 decode HCI packets from the BLE Central device.
 *  	 interrupt is not called.
 *
 * @params 	uint8 taskId
 * 			uint8 events
 *
 * @return uint8 events - Tasks that still need processing
 *
 *  */
uint8 BLE_ProcessEvent(uint8 taskId,uint8 events){

	switch(events)
	{
	case GAP_EVT_EVT:{

		//Retrieve Message from Global Queue
		evtPkt_Gen_s  *tempMsg = (evtPkt_Gen_s *)scheduler_receive_Msg(taskId,GAP_EVT_EVT);
		uint8 event,status;

		if(tempMsg != NULL)
		{
			event = tempMsg->pData[0];
			status = tempMsg->pData[2];
		}
		else
		{
			ERRORFLAG = BLE_NULL_ERROR;
		}

		//For an error condition see what needs to be done to fix the error
		if(status != SUCCESS)
			errorStatusHdr(status);

		//Decode GAP Event
		switch(event)
		{
		case GAP_DeviceInitDone:
		{
			uint8 *IRK = (uint8*)osal_mem_alloc(16);
			uint8 *CSRK = (uint8*)osal_mem_alloc(16);
			uint8 *devAddr = (uint8*)osal_mem_alloc(6);



		uint16 heapBlockCnt = osal_heap_block_free();
		uint16 maxMem = osal_heap_mem_used();



			//Copy Data to new memory locations
			copyArr(tempMsg->pData,devAddr,3,9,0);
			copyArr(tempMsg->pData,IRK,12,28,0);
			copyArr(tempMsg->pData,CSRK,28,44,0);

			//Add Device Information to MASTER BLE Device
			bleMaster.devAddr = devAddr;
			bleMaster.IRK = IRK;
			bleMaster.CSRK = CSRK;




			//Test send message
			//Send MSG
			LinearBuffer_s *tempMsg = osal_mem_alloc(sizeof(LinearBuffer_s));
			tempMsg->dataEnd = 2;
			tempMsg->linBuffer = osal_mem_alloc(2);
			tempMsg->linBuffer[0] = 'A';
			tempMsg->linBuffer[1] = 'B';

			scheduler_send_Msg(UART_TASK_ID,UART_A_TX_EVT,(void*)tempMsg);
			//Set Event
			scheduler_set_Evt(UART_TASK_ID,UART_A_TX_EVT);



		}break;
		case GAP_DeviceDiscovery:
		{
			//Obtain number of devices found
			numOfDevices_InRange = tempMsg->pData[3];

			//Obtain specific Device information from Device information event

			//Set event to start Pairing process(if Devices found)

		}break;

		case GAP_LinkEstablished:
		{

		}break;

		case GAP_LinkTerminated:
		{

		}break;
		case GAP_SignatureUpdated:
		{

		}break;
		case GAP_DeviceInformation:
		{
			//Event representing a device's advertising data OR scan response packet
			uint8 eventType = tempMsg->pData[3];
			uint8 addrType = tempMsg->pData[4];
			uint8 rssi = tempMsg->pData[11];
			uint8 dataLen = tempMsg->pData[12];


			uint8 *devAddr = (uint8*)osal_mem_alloc(6);
			uint8 *advData = (uint8*)osal_mem_alloc(dataLen);


			//Copy Data to new memory locations
			copyArr(tempMsg->pData,devAddr,5,11,0);
			copyArr(tempMsg->pData,advData,13,dataLen + 13,0);

			//Find Or add new BLE device to database

			updateDeviceDB(GAP_DISCOVEREDDEVICE,SUCCESS,devAddr,0,NULL,dataLen,advData,rssi,eventType,addrType);

//-----------------------------------------------TESTCODE----------------------------------------------------
			//Test send message
			//Send MSG OPCODE FOR transmission
			cmdPkt_Gen_s *tempMsgx = osal_mem_alloc(sizeof(cmdPkt_Gen_s));
			tempMsgx->opCode[0] = 0xFE;
			tempMsgx->opCode[1] = 0x00;

			scheduler_send_Msg(BLE_TASK_ID,GAP_CMD_EVT,(void*)tempMsgx);
			//Set Event
			scheduler_set_Evt(BLE_TASK_ID,GAP_CMD_EVT);






		}break;
		case GAP_PassKeyNeeded:
		{

		}break;
		case GAP_BondComplete:
		{

		}break;
		case GAP_AuthenticationComplete:
		{

		}break;
		case GAP_CommandStatus:
		{
			errorStatusHdr(status);

		}break;










		};


		 //Deallocate memory for received message
		 osal_mem_free((void*)tempMsg->pData);
		 osal_mem_free((void*)tempMsg);

		//Mask out completed events
		events &= ~GAP_EVT_EVT;


	}break;
	case GAP_CMD_EVT:{
		//Retrieve Message
		cmdPkt_Gen_s *tempMsg = (cmdPkt_Gen_s *)scheduler_receive_Msg(taskId,GAP_CMD_EVT);
		uint8 opCode[2];	//LSB First*
		opCode[0] = tempMsg->opCode[0];
		opCode[1] = tempMsg->opCode[1];

		uint8 type = 0x01;//Command


		//Build commands and set UART TX Event
		switch(opCode[1])
		{
		case GAP_DeviceInit:{

		//Return Value - CMD Status EVT

			uint8 dataLen = sizeof(GAP_DeviceInitCMD_s);
			uint8 totalPktLen = dataLen + CMDHDRLEN;

			uint8 *pCmd = osal_mem_alloc(totalPktLen);	//Allocate memory for actual command data
			LinearBuffer_s *cmdData = osal_mem_alloc(sizeof(LinearBuffer_s));	//Allocate memory for message to next task

			cmdData->dataEnd = totalPktLen;
			cmdData->isInUse = INUSE;
			cmdData->linBuffer = pCmd;

			//Type(1 byte), opcode(2 bytes), datalength(1 Byte) , Actual Data *
			uint8 profileRole = 0x08; //Central role
			uint8 maxScanResponse = 0x05;	//Take info from at most 5 devices
			uint8 IRK[16] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p'};//{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
			uint8 CSRK[16] = {'A','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p'}; //{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
			uint8 signCounter[4] = {'Q','W','E','R'};//{0,0,0,0};

			uint8 dst_start = 0;
			uint8 src_end = 0;


			 //copyArr(uint8 *src,uint8 *dst,uint8 src_start,uint8 src_end,uint8 dst_start);

			src_end = sizeof(type);
			pCmd[dst_start] = profileRole;

			src_end = sizeof(opCode);
			dst_start += src_end;
			pCmd[dst_start - 1] = opCode[1]; 	//Check to see if both bytes written****
			pCmd[dst_start] = opCode[0];

			src_end = sizeof(dataLen);
			dst_start += src_end;
			pCmd[dst_start] = dataLen;

			src_end = sizeof(profileRole);
			dst_start += src_end;
			pCmd[dst_start] = profileRole;

			src_end = sizeof(maxScanResponse);
			dst_start += src_end;
			pCmd[dst_start] = maxScanResponse;



			src_end = sizeof(IRK);
			dst_start += src_end;
			copyArr(IRK,pCmd,0,src_end,dst_start);

			src_end = sizeof(CSRK);
			dst_start += src_end;
			copyArr(CSRK,pCmd,0,src_end,dst_start);

			src_end = sizeof(signCounter);
			dst_start += src_end;
			copyArr(signCounter,pCmd,0,src_end,dst_start);



/*

			typedef struct{
				//OpCode - 0xFE00
				uint8 profileRole;
				uint8 maxScanResponses;
				uint8 IRK[16];
				uint8 CSRK[16];
				uint8 signCounter[4];


			}GAP_DeviceInitCMD_s;
*/

			//Deallocate memory from calling function/event
			osal_mem_free((void*)tempMsg);

			scheduler_send_Msg(UART_TASK_ID,UART_A_TX_EVT,(void*)tempMsg);	//Set UART TX Event
			scheduler_set_Evt(UART_TASK_ID,UART_A_TX_EVT);


		}break;

		case GAP_DeviceDiscoveryRequest:break;
		case GAP_DeviceDiscoveryCancel:break;
		case GAP_EstablishLinkRequest:break;
		case GAP_TerminateLinkRequest:break;
		case GAP_Authenticate:break;
		case GAP_PasskeyUpdate:break;
		case GAP_Bond:break;
		case GAP_GetParam:break;



		}



		//Mask out completed events
		events &= ~GAP_CMD_EVT;
	}break;
	case GATT_EVT_EVT:{
		//Retrieve Message from Global Queue
			evtPkt_Gen_s  *tempMsg = (evtPkt_Gen_s *)scheduler_receive_Msg(taskId,GATT_EVT_EVT);

			//Decode GAP Event
			switch(tempMsg->eventCode)
			{



			};

			//Mask out completed events
			events &= ~GATT_EVT;


	}break;
	case GATT_CMD_EVT:break;


	};


	return events;
}
/*********************************************************************
 * @fn         BLE_Init
 *
 * @brief
 * 		 This function initializes the BLE Functions such as the device
 * 		 Database.
 *
 * @params 	void
 *
 * @return VOID
 *
 *  */
void BLE_Init(void)
{
	uint8 i = 0;
	//Set default state to all devices in Database
 	for(i = 0; i < NUMOFDEVICES;i++)
	{
 		//Allocate new memory
 		bleDeviceDB[i] = osal_mem_alloc(sizeof(PBLEDevice_s));

 		bleDeviceDB[i]->GAPState = GAP_FREEDEVICE;
		bleDeviceDB[i]->CMDStatus = SUCCESS;
		bleDeviceDB[i]->connHandle = 0;
		bleDeviceDB[i]->LTK = NULL;
		bleDeviceDB[i]->addrType = 0;
		bleDeviceDB[i]->dataLen = 0;
		bleDeviceDB[i]->dataField = NULL;
		bleDeviceDB[i]->rssi = 0;
		bleDeviceDB[i]->advEvtType = 0;
	}


 	bleMaster.CSRK = NULL;
 	bleMaster.IRK = NULL;
 	bleMaster.connHandle = 0;
 	bleMaster.devAddr = NULL;
 	bleMaster.numOfConnectedDevices = 0;


}
/*********************************************************************
 * @fn         addNewDevice
 *
 * @brief
 * 		 This function finds an open slot in the device DB and adds the
 * 		 address
 *
 * @params 	uint8 *devAddr - Device Address
 *
 *
 * @return PBLEDevice_s * - if open slot, NULL - DB Full
 *
 *  */
PBLEDevice_s *addNewDevice(uint8 * devAddr)
{
	uint8 i;

	//Valid input address
	if(devAddr == NULL)
		return NULL;

	for(i = 0; i < NUMOFDEVICES;i++)
	{
		//Check DB for open slot by status
		if(bleDeviceDB[i]->GAPState == GAP_FREEDEVICE)
		{
			bleDeviceDB[i]->devAddr = devAddr;
			bleDeviceDB[i]->GAPState = GAP_DISCONNECTEDDEVICE;
			return bleDeviceDB[i];

		}
	}
	//If NULL Returned, the device DB is full -- ERROR
	return NULL;
}

/*********************************************************************
 * @fn         findDevice
 *
 * @brief
 * 		 This function finds a specific Bluetooth device and returns
 * 		 a pointer to the structure containing its information.
 * 		 Finds the device by address.
 *
 * @params 	uint8 *devAddr - Device Address
 *
 * @return PBLEDevice_s * - if Device found, NULL - otherwise
 *
 *  */
PBLEDevice_s *findDevice(uint8 * devAddr)
{

	uint8 i;
	if(devAddr == NULL)
		return NULL;

	//Attempt to find device by address
	for(i = 0; i < NUMOFDEVICES;i++)
	{
			//Check if in database
			if(compareArray(bleDeviceDB[i]->devAddr,devAddr,6) == SUCCESS)
				return bleDeviceDB[i];
	}
		return NULL;
}

/*********************************************************************
 * @fn         compareArray
 *
 * @brief
 * 		 This function compares two arrays to see if they are the equal.
 *
 * @params 	uint8 *arr1
 * 			uint8 *arr2
 *
 *
 * @return uint8 - SUCCESS or FAILURE
 *  */
uint8 compareArray(uint8 *arr1,uint8 *arr2,uint8 length)
{
	int i;

	for(i = 0; i < length;i++)
	{
		if(arr1[i] != arr2[i])
			return FAILURE;
	}
	return SUCCESS;
}

/*********************************************************************
 * @fn         updateDeviceDB
 *
 * @brief
 * 		 This function adds new information such as a new device
 * 		 or updated security parameters to the device Database.
 * 		 NULL Device Address = Add a new Device to the DB
 *
 * @params
 * 			uint8 GAPState
 * 			uint8 CMDStatus - Current Command for the specific BLE Device status
 * 			uint8 *devAddr - device Address
 * 			uint8 connHandle
 * 			uint8 *IRK
 *			uint8 *CSRK
 *
 *
 * @return VOID
 *
 *  */
void updateDeviceDB(uint8 GAPState,uint8 CMDStatus,uint8 *devAddr,uint8 *connHandle,uint8 *LTK,
					uint8 dataLen, uint8 *data,uint8 rssi,uint8 advEvtType,uint8 addrType)
{
	PBLEDevice_s *currDevice = NULL;

	//Search for Device
	currDevice = findDevice(devAddr);

	//Device not found, add new device
	if(currDevice == NULL)
		currDevice = addNewDevice(devAddr);


	if(GAPState != NULL)
		currDevice->GAPState = GAPState;
	if(CMDStatus != NULL)
		currDevice->CMDStatus = CMDStatus;
	if(connHandle != NULL)
		currDevice->connHandle = connHandle;

	if(LTK != NULL)
	{
		//Replace new key and free memory
		if(currDevice->LTK != NULL)
			osal_mem_free(currDevice->LTK);

		currDevice->LTK = LTK;
	}
	if((dataLen != 0) && (data != NULL))
	{
		//Free memory
		if(currDevice->dataField != NULL)
			osal_mem_free(currDevice->dataField);

		currDevice->dataLen = dataLen;
		currDevice->dataField = data;

	}
	if(rssi != 0)
	{
		currDevice->rssi = rssi;
		currDevice->advEvtType = advEvtType;
		currDevice->addrType = addrType;
	}
}
