#include <msp430.h>
#include "Scheduler.h"

//Static Global Definitions for Main ISR's
   //--------------------------------------------------------------
	uint8 UPDATE_BUFF_AMT = 0;
	static RingBuffer_s *UART_A_RXCircBuf;
	static RingBuffer_s *UART_A_TXCircBuf;
	static RingBuffer_s *UART_B_RXCircBuf;
	static RingBuffer_s *UART_B_TXCircBuf;

//---------------------------------------------------------------

	void memAllocTest(void)
	{
		uint8 *p0,*p1,*p2,*p3,*p4,*p5;
		uint16 freeblkcnt = 0;
		uint8 i,x=2;
		for(i = 0; i < 1000;i++)
		{
			switch(i)
			{
			case 40: p4 = NULL;break;
			case 80: p5 = NULL;break;
			case 120: p2 = NULL;break;
			case 200: p2 = NULL;break;
			case 500: p2 = NULL;break;
			}

			int x1 = sizeof(unsigned int);

			if(x == 5)
				p2 = NULL;
			x+=1;
			p0 = osal_mem_alloc(x * 3);


			if(x % 2 == 0)
			{	p1 = osal_mem_alloc(x);
				if(p1 != NULL)
				{
					*p1 = 'S';
					osal_mem_free(p1);
				}
			}
			if(p0 != NULL)
			{
			*p0 = 'L';
			}
			freeblkcnt = osal_heap_block_free();
		}
	}





	void SetVcoreUp (unsigned int level)
	{
	  // Open PMM registers for write
	  PMMCTL0_H = PMMPW_H;
	  // Set SVS/SVM high side new level
	  SVSMHCTL = SVSHE + SVSHRVL0 * level + SVMHE + SVSMHRRL0 * level;
	  // Set SVM low side to new level
	  SVSMLCTL = SVSLE + SVMLE + SVSMLRRL0 * level;
	  // Wait till SVM is settled
	  while ((PMMIFG & SVSMLDLYIFG) == 0);
	  // Clear already set flags
	  PMMIFG &= ~(SVMLVLRIFG + SVMLIFG);
	  // Set VCore to new level
	  PMMCTL0_L = PMMCOREV0 * level;
	  // Wait till new level reached
	  if ((PMMIFG & SVMLIFG))
	    while ((PMMIFG & SVMLVLRIFG) == 0);
	  // Set SVS/SVM low side to new level
	  SVSMLCTL = SVSLE + SVSLRVL0 * level + SVMLE + SVSMLRRL0 * level;
	  // Lock PMM registers for write access
	  PMMCTL0_H = 0x00;
	}

	void setupMSPClock()
	{
		  	  volatile unsigned int i;



			  // Increase Vcore setting to level3 to support fsystem=25MHz
			  // NOTE: Change core voltage one level at a time..
			  SetVcoreUp (0x01);
			  SetVcoreUp (0x02);
			  SetVcoreUp (0x03);

			  UCSCTL3 = SELREF_2;                       // Set DCO FLL reference = REFO
			  UCSCTL4 |= SELA_2;                        // Set ACLK = REFO

			  __bis_SR_register(SCG0);                  // Disable the FLL control loop
			  UCSCTL0 = 0x0000;                         // Set lowest possible DCOx, MODx
			  UCSCTL1 = DCORSEL_7;                      // Select DCO range 50MHz operation
			  UCSCTL2 = FLLD_0 + 762;                   // Set DCO Multiplier for 25MHz  						SET TO 6 for 20 MHZ
			                                            // (N + 1) * FLLRef = Fdco
			                                            // (762 + 1) * 32768 = 25MHz
			                                            // Set FLL Div = fDCOCLK/2
			  __bic_SR_register(SCG0);                  // Enable the FLL control loop

			  // Worst-case settling time for the DCO when the DCO range bits have been
			  // changed is n x 32 x 32 x f_MCLK / f_FLL_reference. See UCS chapter in 5xx
			  // UG for optimization.
			  // 32 x 32 x 25 MHz / 32,768 Hz ~ 780k MCLK cycles for DCO to settle
			  __delay_cycles(782000);

			  // Loop until XT1,XT2 & DCO stabilizes - In this case only DCO has to stabilize
			  do
			  {
			    UCSCTL7 &= ~(XT2OFFG + XT1LFOFFG + DCOFFG);
			                                            // Clear XT2,XT1,DCO fault flags
			    SFRIFG1 &= ~OFIFG;                      // Clear fault flags
			  }while (SFRIFG1&OFIFG);                   // Test oscillator fault flag


			//REMOVEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE


	}
//-------------------------------------------------------------------------



void main(void) {
	WDTCTL = WDTPW | WDTHOLD;	// Stop Watchdog timer

	setupMSPClock();


/*
	uint8 *memPtr = (uint8*)(0x2400);
	uint16 i = 0;
	for(i = 0; i < 3072;i++)
		memPtr[i] = 'H';

	uint16 j = 0;
	memPtr = (uint8*)(0x3200);
	for(; j < 0x11ff ;j++)
		memPtr[j] = 's';
*/


	// Initialize the Memory Allocation System
	osal_mem_init();


	//Initialize UART RX TX Buffers
//UART_A_RXCircBuf = initializeBuffer(RXBUFFER_INIT);
//UART_A_TXCircBuf = initializeBuffer(TXBUFFER_INIT);
	//UART_B_RXCircBuf = initializeBuffer(RXBUFFER_INIT);
	//UART_B_TXCircBuf = initializeBuffer(TXBUFFER_INIT);


	/*---------------------------------------------------------------------
		Test Code Block
	*/
		//Set CTS(P1.7) as input  and enable interrupts
		//P1DIR &= ~BIT7;
		//P6DIR |= BIT7;
		//P6OUT |= BIT7;
		//P6OUT &= ~BIT7;

		//Test Memory Allocation
		osal_mem_kick();
		memAllocTest();




		_bis_SR_register(GIE);


	/*---------------------------------------------------------------------
	 	 End Test Code Block

	 	 		  TA0CCTL0 |= CCIE;                          // CCR0 interrupt enabled
		  TA0CCR0 = 65535;
		  TA0CTL = TASSEL_2 + MC_1 + TACLR;         // SMCLK, upmode, clear TAR

	*/

	//Start the HCI system
	scheduler_start_system();

		while(1);
/*
-----------------------------------------------------------------------
*/
}









// Vector 0 - no interrupt
// Vector 2 - RXIFG
// Vector 4 - TXIFG

#pragma vector=USCI_A1_VECTOR
__interrupt void USCI_A1_ISR(void)
{
	//Flag to skip current RX Packet if all buffers are full
	static uint8 SkipPacket = FALSE;


	//Number of bytes either received or transmitted
		 static uint8 TxByteCtr = 0;
		 static uint8 RxByteCtr = 0;

	//Index of Buffer currently being used
		 static uint8 currTxBuf = 0;
		 static uint8 currRxBuf = 0;
	//Index of end of data
		// static uint8 RxPktEnd = BUFFERSIZE;
		 static uint8 RxPktEnd = 44;
		 static uint8 TxPktEnd = 0;

	//Status of adding to a buffer
		 uint8 addStatus = SUCCESS;
		 volatile uint8 rxByte = 0;







	switch(__even_in_range(UCA1IV,4))
	{
	case UARTTXINT:
			{
			 //UCA1TXBUF = 'a';

			}break;
	case UARTRXINT:
	{




//--------------------Test Code Block--------------------------
		 static int count = 0;
		count++;
		__delay_cycles(5000);

		 if(UCA1STAT & UCOE)
			 ERRORFLAG = UART_BUFFEROVERFLOW_ERROR;
//--------------------End Test Code Block--------------------------


		 //Read Received Byte into Circular RX Buffer
		 rxByte = UCA1RXBUF;
		 RxByteCtr++;
		 /*Buffer writing procedure
		  * 0)Update NumOfBufInUse
			1)Test to see if the overall Circular Buffer is fully in use - STOP ERROR
			2)Find open Buffer,Set in use flag,increment Total buffers in use
			3)Write to same open buffer until : Full or End transmission
			4)If Full and Transmission not ended:Send MSG with Full Buffer->DO NOT reset rxByteCtr,read into new buffer for next rxByte->Send MSG & Set Event when Complete

			Cases: 	1) End of incoming data packet
					2)Buffer is full BUT Data not complete
					3)Buffer Not full AND Data not complete
						3A)RxByte == 3, parse data packet length
						3B) DO nothing




				*/

		 //Calculate number of buffers in use
		 int i;
		 if(UPDATE_BUFF_AMT)
		 {
		 	 UART_A_RXCircBuf->numOfBufInUse = 0;
			 for(i = 0; i < NUMOFBUFFERS;i++)
			 {
				 if(UART_A_RXCircBuf->circBuffer[i]->isInUse == 1)
					 UART_A_RXCircBuf->numOfBufInUse++;
			 }
			 UPDATE_BUFF_AMT = 0;
		 }





		 //Buffer's not full and NOT skipping a previous Packet
		 if((!isCircBufFull(UART_A_RXCircBuf)) && (!SkipPacket))
		 {
			 //Find a new Buffer if the one is currently being used
			 if(UART_A_RXCircBuf->circBuffer[currRxBuf]->isInUse)
			 {
				 currRxBuf = findOpenBuffer(UART_A_RXCircBuf,currRxBuf);
			 }

			 //Add Data to circular Buffer
			 addStatus =  addToBuffer(UART_A_RXCircBuf,currRxBuf,rxByte);

			  if(addStatus == SUCCESS)
			  {
				  //End of data Reached
				  if(RxByteCtr == RxPktEnd)
				  {
					  //Reset Byte Counter
					  RxByteCtr = 0;
					  RxPktEnd = BUFFERSIZE;

					  //Set in use flag so it doesen't get overwritten
					  UART_A_RXCircBuf->circBuffer[currRxBuf]->isInUse = 1;
					  UPDATE_BUFF_AMT = 1;
					  //Send MSG
					  scheduler_send_Msg(UART_TASK_ID,UART_A_RX_EVT,(void*)UART_A_RXCircBuf->circBuffer[currRxBuf]);
					  //Set Event
					  scheduler_set_Evt(UART_TASK_ID,UART_A_RX_EVT);
				  }

				  //Check for full buffer && Not finished with incoming Packet data
				  else if((isBuffFull((*(UART_A_RXCircBuf->circBuffer[currRxBuf])))))
				  {

					  //Make sure there's enough space for the rest of the packet
					  if((!isCircBufFull(UART_A_RXCircBuf)))
					  {
						  //Just don't RESET RX Byte Counter
						  UART_A_RXCircBuf->circBuffer[currRxBuf]->isInUse = 1;

						  //SEND SCHED MSG
						  scheduler_send_Msg(UART_TASK_ID,UART_A_RX_EVT,UART_A_RXCircBuf->circBuffer[currRxBuf]);
					  }
					  else
					  {
						  //Not enough room, skip rest of packet and set error Flag
						  SkipPacket  = 1;
						  ERRORFLAG = BUFFERFULLERROR;
					  }
				  }
				  else if(RxByteCtr == 0x04)
				  {
					 //End of data transmission
					 RxPktEnd = UART_A_RXCircBuf->circBuffer[currRxBuf]->linBuffer[EVTDATALENINDEX] + RXOFFSET;
				  }

			  }
			  //ADD STATUS FAILURE
			  else
			  {
				//SET SOME KIND OF FLAG
				  ERRORFLAG = BUFFERADDFAILURE;
			  }

		 }
		 else
		 {
			 //Circular Buffer is Full so skip the current packet and try again later
			 SkipPacket = TRUE;
			 //Continue to count bytes BUT just to make sure to start at next valid buffer

			 if(RxByteCtr == 0x03)
				 RxPktEnd = rxByte + RXOFFSET;

			 if(RxByteCtr == RxPktEnd)
			 {
				 //Reset Byte Counter
				 RxByteCtr = 0;
				 RxPktEnd = BUFFERSIZE;
				 //Packet Skip Completed
				 SkipPacket = FALSE;
			 }
		 }




	}break;


	default: break;
	}

}


#pragma vector=PORT1_VECTOR
__interrupt void PORT_1_ISR(void)
{


	switch(P1IV)
	{
	case BIT7:
		P4DIR |= ( BIT7);
		P4OUT ^= ( BIT7);

		break;
	case BIT4:
		P1IFG = 0;
		P4OUT ^= ( BIT7);
		while(P1IV);
		break;
	}

	//P1IES ^= BIT7;


	PAIFG = 0;
}










#pragma vector=TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR(void)
{

  volatile static long int timer = 0;
  timer++;

  if(timer == 5000)
  {
	  P6DIR |= BIT7;
	  timer = 0;
  }
}


