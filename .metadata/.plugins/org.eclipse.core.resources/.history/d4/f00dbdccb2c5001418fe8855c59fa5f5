#include <msp430.h>
#include "Mem_Manager.h"
#include "taskScheduler.h"
#include "UART_HCI.h"

//Static Global Definitions for Main ISR's
   //--------------------------------------------------------------
	static RingBuffer_s *UART_A_RXCircBuf;
	static RingBuffer_s *UART_A_TXCircBuf;
	static RingBuffer_s *UART_B_RXCircBuf;
	static RingBuffer_s *UART_B_TXCircBuf;

#define UARTTXINT 4
#define UARTRXINT 2

#define CMDPKT 0x01
#define DATAPKT 0x02
#define EVTPKT 0x04

#define RXOFFSET 3

 //---------------------------------------------------------------

void main(void) {
	WDTCTL = WDTPW | WDTHOLD;	// Stop watchdog timer

	osal_mem_init();

	//Initialize UART RX TX Buffers
	UART_A_RXCircBuf = initializeBuffer(RXBUFFER_INIT);
	//UART_A_TXCircBuf = initializeBuffer(TXBUFFER_INIT);
	//UART_B_RXCircBuf = initializeBuffer(RXBUFFER_INIT);
	//UART_B_TXCircBuf = initializeBuffer(TXBUFFER_INIT);

	//Call  scheduler_start_system() , in Scheduler
	//Place memory kick in scheduler .cpp!!!!!!!!!!!!!!!!!!After memory initialization****




	  osal_mem_kick();
/*---------------------------------------------------------------------
Test Code Block
*/


/*
-----------------------------------------------------------------------
*/

	  P4SEL |= BIT4+BIT5;                       // P3.3,4 = USCI_A1 TXD/RXD
	  UCA1CTL1 |= UCSWRST;                      // **Put state machine in reset**
	  UCA1CTL1 |= UCSSEL_2;                     // SMCLK
	  UCA1BR0 = 9;                              // 1MHz 115200 (see User's Guide)
	  UCA1BR1 = 0;                              // 1MHz 115200
	  UCA1MCTL |= UCBRS_1 + UCBRF_0;            // Modulation UCBRSx=1, UCBRFx=0
	  UCA1CTL1 &= ~UCSWRST;                     // **Initialize USCI state machine**
	  UCA1IE |= UCRXIE;                         // Enable USCI_A1 RX interrupt



		_bis_SR_register(LPM0_bits + GIE);




		//while(1);
}


// Vector 0 - no interrupt
// Vector 2 - RXIFG
// Vector 4 - TXIFG

#pragma vector=USCI_A1_VECTOR
__interrupt void USCI_A1_ISR(void)
{
	//Flag to skip current RX Packet if all buffers are full
	static uint8 SkipPacket = FALSE;
	static uint8 pktType = 0;


	//Number of bytes either received or transmitted
		 static uint8 TxByteCtr = 0;
		 static uint8 RxByteCtr = 0;

	//Index of Buffer currently being used
		 static uint8 currTxBuf = 0;
		 static uint8 currRxBuf = 0;
	//Index of end of data
		// static uint8 RxPktEnd = BUFFERSIZE;
		 static uint8 RxPktEnd = 44;
		 static uint8 TxPktEnd = 0;

	//Status of adding to a buffer
		 uint8 addStatus = SUCCESS;
		 volatile uint8 rxByte = 0;

		 uint8 pktLenIndex = 0;








	switch(__even_in_range(UCA1IV,4))
	{
	case UARTTXINT:
			{
			 //UCA1TXBUF = 'a';

			}break;
	case UARTRXINT:
	{

		 //Read Received Byte into Circular RX Buffer
		 rxByte = UCA1RXBUF;
		 RxByteCtr++;
		 /*Buffer writing procedure
			1)Test to see if the overall Circular Buffer is fully in use - STOP ERROR
			2)Find open Buffer,Set in use flag,increment Total buffers in use
			3)Write to same open buffer until : Full or End transmission
			4)If Full and Transmission not ended:Send MSG with Full Buffer->DO NOT reset rxByteCtr,read into new buffer for next rxByte->Send MSG & Set Event when Complete

			Cases: 	1) End of incoming data packet
					2)Buffer is full BUT Data not complete
					3)Buffer Not full AND Data not complete
						3A)RxByte == 3, parse data packet length
						3B) DO nothing




				*/


		 //Save Packet type
		 if(RxByteCtr == 1)
			 pktType = rxByte;

		 //Buffer's not full and NOT skipping a previous Packet
		 if((!isCircBufFull(UART_A_RXCircBuf)) && (!SkipPacket))
		 {
			 //Find a new Buffer if the one is currently being used
			 if(UART_A_RXCircBuf->circBuffer[currRxBuf]->isInUse)
			 {
				 currRxBuf = findOpenBuffer(UART_A_RXCircBuf,currRxBuf);
			 }

			 //Add Data to circular Buffer
			 addStatus =  addToBuffer(UART_A_RXCircBuf,currRxBuf,rxByte);

			  if(addStatus == SUCCESS)
			  {
				  //End of data Reached
				  if(RxByteCtr == RxPktEnd)
				  {
					  //Reset Byte Counter
					  RxByteCtr = 0;
					  RxPktEnd = BUFFERSIZE;

					  //Set in use flag so it doesen't get overwritten
					  UART_A_RXCircBuf->circBuffer[currRxBuf]->isInUse = 1;
					  UART_A_RXCircBuf->numOfBufInUse++;
					  //Send MSG
				  }

				  //Check for full buffer && Not finished with incoming Packet data
				  else if((isBuffFull((*(UART_A_RXCircBuf->circBuffer[currRxBuf])))))
				  {
					  //Just don't RESET RX Byte Counter
					  UART_A_RXCircBuf->circBuffer[currRxBuf]->isInUse = 1;
					  UART_A_RXCircBuf->numOfBufInUse++;
					  //SEND SCHED MSG
				  }
				  else if(RxByteCtr == 0x03)
				  {
					 switch(packetType)
					 {
						case CMDPKT:
							pktLenIndex = 3; break;
						case EVTPKT:
							pktLenIndex = 2; break;
						case DATAPKT:
							pktLenIndex = 3; break;
					 }
					 //End of data transmission
					 RxPktEnd = UART_A_RXCircBuf->circBuffer[currRxBuf]->linBuffer[pktLenIndex] + RXOFFSET;
				  }

			  }


		 }
		 else
		 {
			 //Circular Buffer is Full so skip the current packet and try again later
			 SkipPacket = TRUE;
			 //Continue to count bytes BUT just to make sure to start at next valid buffer


			 if(RxByteCtr == RxPktEnd)
			 {
				 //Reset Byte Counter
				 RxByteCtr = 0;
				 RxPktEnd = BUFFERSIZE;

			 }


			 if((RxByteCtr == 0x03) && (pktType == EVTPKT))
			 {
				RxPktEnd = rxByte;
			 }
			 else if((RxByteCtr == 0x04) && (pktType == (CMDPKT || DATAPKT)))
			 {
				 RxPktEnd = rxByte;
			 }



		 }

	}break;


	default: break;
	}

}

